module Day2 (part1,test1,part2) where

import           Control.Applicative
import           Data.List
import           Data.Maybe
import           Text.Trifecta

data Move = U | D | L | R
  deriving (Eq, Show)

codeParser :: Parser [[Move]]
codeParser = some (some moveParser <* skipOptional newline)

moveParser :: Parser Move
moveParser = try (U <$ char 'U' )
  <|> try (D <$ char 'D' )
  <|> try (L <$ char 'L' )
  <|> (R <$ char 'R' )

move :: MoveAlg -> Int -> Move -> Int
move (MoveAlg moveFn getRow getCol vals) i m
  | moved `elem` vals && isOnKeypad m = moved
  | otherwise                         = i
  where
    isOnKeypad U = getCol i == getCol moved
    isOnKeypad D = getCol i == getCol moved
    isOnKeypad L = getRow i == getRow moved
    isOnKeypad R = getRow i == getRow moved
    moved = moveFn m i

doCodeLine :: MoveAlg -> Int -> [Move] -> Int
doCodeLine ma = foldl' (move ma)

doCode :: MoveAlg -> [[Move]] -> [Int]
doCode moveAlg = foldl' f []
  where
    f [] m = [doCodeLine moveAlg 5 m]
    f cs m = cs ++ [doCodeLine moveAlg (last cs) m]

data MoveAlg = MoveAlg MoveFn RowFn ColFn [Int]
type MoveFn = Move -> Int -> Int
type RowFn = Int -> Int
type ColFn = Int -> Int

moveFn1 :: Move -> Int -> Int
moveFn1 D = (+3)
moveFn1 U = (+ (-3))
moveFn1 L = (+ (-1))
moveFn1 R = (+ 1)
getRow1 :: Int -> Int
getRow1 x = (x-1) `div` 3
getCol1 :: Int -> Int
getCol1 x = x `mod` 3

grid2 :: [[Maybe Int]]
grid2 =[ [Nothing,Nothing,Just 1,Nothing,Nothing]
      , [Nothing,Just 2,Just 3,Just 4,Nothing]
      , [Just 5,Just 6,Just 7,Just 8,Just 9]
      , [Nothing,Just 10,Just 11,Just 12,Nothing]
      , [Nothing,Nothing,Just 13,Nothing,Nothing]
      ]
moveFn2 :: Move -> Int -> Int
moveFn2 D i
  | row < 4 && isJust next = fromJust next
  | otherwise = i
  where
    row = getRow2 i
    col = getCol2 i
    next = (grid2 !! (row + 1)) !! col
moveFn2 U i
  | row > 0 && isJust next = fromJust next
  | otherwise              = i
  where
    row = getRow2 i
    col = getCol2 i
    next = (grid2 !! (row - 1)) !! col
moveFn2 L i = i -1
moveFn2 R i = i + 1
getRow2 :: Int -> Int
getRow2 x = fromJust $ findIndex (/= Nothing) $ map (elemIndex (Just x)) grid2
getCol2 :: Int -> Int
getCol2 x = fromJust $ head $ filter (/= Nothing) $ map (elemIndex (Just x)) grid2

part1 :: String -> [Int]
part1 s = case code of
  Failure d -> error (show d)
  Success c -> doCode (MoveAlg moveFn1 getRow1 getCol1 [1..9]) c
  where code = parseString codeParser mempty s

part2 :: String -> [Int]
part2 s = case code of
  Failure d -> error (show d)
  Success c -> doCode (MoveAlg moveFn2 getRow2 getCol2 [1..13]) c
  where code = parseString codeParser mempty s

test1 :: String
test1 = "ULL\nRRDDD\nLURDL\nUUUUD"
input :: String
input = "LLLRLLULLDDLDUDRDDURLDDRDLRDDRUULRULLLDLUURUUUDLUUDLRUDLDUDURRLDRRRUULUURLUDRURULRLRLRRUULRUUUDRRDDRLLLDDLLUDDDLLRLLULULRRURRRLDRLDLLRURDULLDULRUURLRUDRURLRRDLLDDURLDDLUDLRLUURDRDRDDUURDDLDDDRUDULDLRDRDDURDLUDDDRUDLUDLULULRUURLRUUUDDRLDULLLUDLULDUUDLDLRRLLLRLDUDRUULDLDRDLRRDLDLULUUDRRUDDDRDLRLDLRDUDRULDRDURRUULLUDURURUUDRDRLRRDRRDRDDDDLLRURULDURDLUDLUULDDLLLDULUUUULDUDRDURLURDLDDLDDUULRLUUDLDRUDRURURRDDLURURDRLRLUUUURLLRR\nUUUUURRRURLLRRDRLLDUUUUDDDRLRRDRUULDUURURDRLLRRRDRLLUDURUDLDURURRLUDLLLDRDUDRDRLDRUDUDDUULLUULLDUDUDDRDUUUDLULUDUULLUUULURRUDUULDUDDRDURRLDDURLRDLULDDRUDUDRDULLRLRLLUUDDURLUUDLRUUDDLLRUURDUDLLDRURLDURDLRDUUDLRLLRLRURRUDRRLRDRURRRUULLUDLDURDLDDDUUDRUUUDULLLRDRRDRLURDDRUUUDRRUUDLUDDDRRRRRLRLDLLDDLRDURRURLLLULURULLULRLLDDLDRLDULLDLDDDRLUDDDUDUDRRLRDLLDULULRLRURDLUDDLRUDRLUURRURDURDRRDRULUDURRLULUURDRLDLRUDLUDRURLUDUUULRRLRRRULRRRLRLRLULULDRUUDLRLLRLLLURUUDLUDLRURUDRRLDLLULUDRUDRLLLRLLDLLDUDRRURRLDLUUUURDDDUURLLRRDRUUURRRDRUDLLULDLLDLUDRRDLLDDLDURLLDLLDLLLDR\nLRDULUUUDLRUUUDURUUULLURDRURDRRDDDLRLRUULDLRRUDDLLUURLDRLLRUULLUDLUDUDRDRDLUUDULLLLRDDUDRRRURLRDDLRLDRLULLLRUUULURDDLLLLRURUUDDDLDUDDDDLLLURLUUUURLRUDRRLLLUUULRDUURDLRDDDUDLLRDULURURUULUDLLRRURDLUULUUDULLUDUUDURLRULRLLDLUULLRRUDDULRULDURRLRRLULLLRRDLLDDLDUDDDUDLRUURUDUUUDDLRRDLRUDRLLRDRDLURRLUDUULDRRUDRRUDLLLLRURRRRRUULULLLRDRDUDRDDURDLDDUURRURLDRRUDLRLLRRURULUUDDDLLLRDRLULLDLDDULDLUUDRURULLDLLLLDRLRRLURLRULRDLLULUDRDR\nRURRRUDLURRURLURDDRULLDRDRDRRULRRDLDDLDUUURUULLRRDRLDRRDRULLURRRULLLDULDDDDLULRUULRURUDURDUDRLRULLLRDURDDUDDRDLURRURUURDLDDDDDURURRURLLLDDLDRRDUDDLLLDRRLDDUUULDLLDRUURUDDRRLDUULRRDDUDRUULRLDLRLRUURLLDRDLDRLURULDLULDRULURLLRRLLDDDURLRUURUULULRLLLULUDULUUULDRURUDDDUUDDRDUDUDRDLLLRDULRLDLRRDRRLRDLDDULULRLRUUDDUDRRLUDRDUUUDRLLLRRLRUDRRLRUUDDLDURLDRRRUDRRDUDDLRDDLULLDLURLUUDLUDLUDLDRRLRRRULDRLRDUURLUULRDURUDUUDDURDDLRRRLUUUDURULRURLDRURULDDUDDLUDLDLURDDRRDDUDUUURLDLRDDLDULDULDDDLDRDDLUURDULLUDRRRULRLDDLRDRLRURLULLLDULLUUDURLDDULRRDDUULDRLDLULRRDULUDUUURUURDDDRULRLRDLRRURR\nUDDDRLDRDULDRLRDUDDLDLLDDLUUURDDDLUDRDUDLDURLUURUDUULUUULDUURLULLRLUDLLURUUUULRLRLLLRRLULLDRUULURRLLUDUDURULLLRRRRLRUULLRDRDRRDDLUDRRUULUDRUULRDLRDRRLRRDRRRLULRULUURRRULLRRRURUDUURRLLDDDUDDULUULRURUDUDUDRLDLUULUDDLLLLDRLLRLDULLLRLLDLUUDURDLLRURUUDDDDLLUDDRLUUDUDRDRLLURURLURRDLDDDULUURURURRLUUDUDLDLDDULLURUDLRLDLRLDLDUDULURDUDRLURRRULLDDDRDRURDDLDLULUDRUULDLULRDUUURLULDRRULLUDLDRLRDDUDURRRURRLRDUULURUUDLULDLRUUULUDRDRRUDUDULLDDRLRDLURDLRLUURDRUDRDRUDLULRUDDRDLLLRLURRURRLDDDUDDLRDRRRULLUUDULURDLDRDDDLDURRLRRDLLDDLULULRRDUDUUDUULRDRRDURDDDDUUDDLUDDUULDRDDULLUUUURRRUUURRULDRRDURRLULLDU"
